/*==========================================================================
	无线通信模块
	1.串口5, 115200, 8+n+1
	2.用定时器5作为串口接收一帧数据的5ms超时定时
	2016.1.23	Li
==========================================================================*/
#include "wireless.h"

/****************************************************
	函数名称：void Wireless_Init( void )
	功		能：串口5初始化,19200,8+n+1,用于无线串口模块的通讯
	入		参：无
	返		值：无
****************************************************/
void Wireless_Init( void )
{
	uart5_init(36,115200);
}
/****************************************************
	串口5初始化函数
	pclk1:PCLK1时钟频率(Mhz); 最高36MHz
	bound:波特率
****************************************************/
void uart5_init(u32 pclk1,u32 bound)
{
	float temp;
	u16 mantissa;
	u16 fraction;
	temp=(float)(pclk1*1000000)/(bound*16);	//得到USARTDIV
	mantissa=temp;				 									//得到整数部分
	fraction=(temp-mantissa)*16; 						//得到小数部分	 
  mantissa<<=4;
	mantissa+=fraction;
	
	RCC->APB2ENR|=1<<4;   	//使能PORTC口时钟
	RCC->APB2ENR|=1<<5;   	//使能PORTD口时钟
	RCC->APB1ENR|=1<<20;  	//使能串口5时钟 
	GPIOC->CRH&=0XFFF0FFFF;	//IO状态设置
	GPIOC->CRH|=0X000B0000;	//IO状态设置
	GPIOD->CRL&=0XFFFFF0FF;	//IO状态设置
	GPIOD->CRL|=0X00000800;	//IO状态设置
	
	RCC->APB1RSTR|=1<<20;   //复位串口5
	RCC->APB1RSTR&=~(1<<20);//停止复位
	//波特率设置
 	UART5->BRR=mantissa; 		// 波特率设置	 
	UART5->CR1|=0X000C;  		//1位停止,无校验位.
	
	//使能接收中断
	UART5->CR1|=1<<8;    		//PE中断使能
	UART5->CR1|=1<<5;    		//接收缓冲区非空中断使能
	MY_NVIC_Init(1,3,UART5_IRQn,2);//组2,抢占优先级1,响应优先级3(和串口4有相同的中断优先级)
}
/****************************************************
	串口5使能
****************************************************/
void USART5_En( void )
{
	UART5->CR1|=0X2000;  //USART5 使能
}
/****************************************************
	串口5发送函数
****************************************************/
// 发送一个字节数据
void USART5_SendByte(u8 data)
{
	UART5->DR=data;
	while((UART5->SR&0x0080) == 0x00);//等待发送数据寄存器为空
}
// 发送字符串
void USART5_SendString(u8 *Pdata)
{
	while( *Pdata != 0)
	{
		USART5_SendByte( *Pdata );
		Pdata++;
	}
}
// 发送Length长的字节数据
void USART5_Send(u8 *Pdata, u8 Length)
{
	u8 temp;
	for(temp=0;temp<Length;temp++)
	{
		USART5_SendByte(Pdata[temp]);
	}
}
/****************************************************
	函数名称：void UART5_IRQHandler(void),串口5接收中断
	功		能：接收上位机的数据帧,每帧固定为8字节,接收完
						一帧数据后返回给上位机一帧数据,固定为6字节
						,以表示此次接收数据的状态(成功/失败).
						一帧数据完毕通过启动定时器5进行5ms超时时间
						计时,超时进入中断后,表示一帧数据结束,对数据
						进行处理.
	入		参：无
	返		值：无
****************************************************/
u8  USART5_TX_BUF[20];	//发送缓冲区
u8  USART5_RX_BUF[20];//接收缓冲,最大USART2_REC_LEN个字节.
u8  USART5_RX_STA=0; //接收状态标记
										 //接收状态
										 //bit8，	接收完成标志
										 //bit7~0，接收到的有效字节数目
void UART5_IRQHandler(void)
{
	u8 res;
	if(UART5->SR&(1<<5))//接收到数据
	{
		res=UART5->DR;
		USART5_RX_BUF[USART5_RX_STA++]=res;
		
		TIM5_IRQSource=WIRELESS_TRIG;	//设置timer 5的中断源标志位为串口5触发
		TIM5_Dis();				//关定时器中断
		TIM5_ClrCont();		//清计数器值
		TIM5_En();				//开定时器中断
	}
}


//===========================================================================================================================//
//																					End Of File																																			 //
//===========================================================================================================================//
